#!/bin/bash
# Taskwarrior Flow - Imperative commands for task management
# Makes Taskwarrior easier to use for AI agents

set -e

SCRIPT_NAME="tw-flow"
VERSION="1.3.0"

# Detect project and set TASKDATA if PROJECT_ID is available
detect_and_set_taskdata() {
    if [ -n "$PROJECT_ID" ]; then
        export TASKDATA="$HOME/.task/$PROJECT_ID"
        mkdir -p "$TASKDATA"
    fi
}

# Set TASKDATA before doing anything
detect_and_set_taskdata

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Helper functions
error() {
    echo -e "${RED}ERROR:${NC} $1" >&2
    exit 1
}

success() {
    echo -e "${GREEN}✓${NC} $1"
}

info() {
    echo -e "${CYAN}ℹ${NC} $1"
}

warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

# Helper: Shorten UUID for display (8 chars)
short_id() {
    local id="$1"
    if [[ "$id" =~ ^[0-9a-fA-F-]{8,}$ ]]; then
        echo "${id:0:8}"
    else
        echo "$id"
    fi
}

# Helper: Resolve UUID (expand short UUID or validate full UUID)
resolve_uuid() {
    local input="$1"
    
    # If it's already a full UUID (36 chars with dashes), return it
    if [[ "$input" =~ ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$ ]]; then
        echo "$input"
        return 0
    fi
    
    # If it's a short UUID (8 chars), find the matching task
    if [[ "$input" =~ ^[0-9a-fA-F]{8}$ ]]; then
        local full_uuid
        full_uuid=$(task export 2>/dev/null | jq -r ".[] | select(.uuid | startswith(\"$input\")) | .uuid" | head -1)
        if [[ -n "$full_uuid" ]]; then
            echo "$full_uuid"
            return 0
        fi
    fi
    
    # Otherwise, assume it's a valid identifier and return as-is
    echo "$input"
}



show_usage() {
    cat <<EOF
${CYAN}Taskwarrior Flow${NC} - Simplified task management commands

${YELLOW}USAGE:${NC}
    $SCRIPT_NAME <command> [options]

${YELLOW}COMMANDS:${NC}

  ${GREEN}Initiatives:${NC}
    initiative|ini <initiative> <tasks...>    Create a new initiative with multiple tasks
                                       Tasks format: "mode|description|tag|due_offset"
                                       Modes: DESIGN, INVESTIGATE, GUIDE, EXECUTE, TEST, DEBUG, REVIEW, PR-REVIEW
    
  ${GREEN}Execution:${NC}
    next [initiative]                Show next task(s) ready to work
    execute <id>                       Start working on a task
    done <id> [note]                   Complete a task with optional note
    outcome <id> <message>             Record final outcome before closing
    handoff <id> <message>             Start next task and add handoff note
    pause <id>                         Pause work on a task
    
  ${GREEN}Context:${NC}
    note <id> <type> <message>         Add structured annotation
                                       Types: research, decision, blocked, lesson, ac, note, link
    context <id>                       Show full task context (annotations, deps, etc.)
    
  ${GREEN}Viewing:${NC}
    initiatives|inis                              List all initiatives with pending tasks
    status [initiative]              Show initiative status overview
    active                             Show currently active tasks
    blocked                            Show blocked tasks
    overdue                            Show overdue tasks
    
  ${GREEN}Modifications:${NC}
    urgent <id> [urgency]              Make task urgent (default: 15.0)
    block <id> <depends_on_id>         Add dependency to task
    unblock <id> <depends_on_id>       Remove dependency from task
    wait <id> <date>                   Put task on hold until date

${YELLOW}EXAMPLES:${NC}

  # Create a 3-task initiative with modes
  $SCRIPT_NAME initiative login-feature \\
    "DESIGN|Design auth flow|research|today" \\
    "EXECUTE|Implement JWT|implementation|tomorrow" \\
    "TEST|Write tests|testing|2days"

  # See what's next
  $SCRIPT_NAME next login-feature

  # Start working
  $SCRIPT_NAME execute 42

  # Add research note
  $SCRIPT_NAME note 42 research "Found passport.js library"

  # Record outcome
  $SCRIPT_NAME outcome 42 "Implemented OAuth login flow"

  # Complete task
  $SCRIPT_NAME done 42

  # Handoff to next task
  $SCRIPT_NAME handoff 43 "Pick up implementation. See Task 42 for design docs."

  # Check status
  $SCRIPT_NAME status login-feature
  $SCRIPT_NAME done 42 "Completed design phase"

  # Check status
  $SCRIPT_NAME status login-feature

EOF
}

# Command: initiative - Create a new initiative with tasks
cmd_initiative() {
    local initiative="$1"
    shift
    
    [[ -z "$initiative" ]] && error "Initiative name required"
    [[ $# -eq 0 ]] && error "At least one task required"
    
    info "Creating initiative: $initiative"
    
    local urgency=9.0
    local task_ids=()
    local prev_id=""
    
    for task_spec in "$@"; do
        # Parse mode|description|tag|due_offset
        IFS='|' read -r mode description tag due_offset <<< "$task_spec"
        
        # If the first field isn't a known mode, assume the old format (description|tag|due)
        # or that mode was omitted.
        if [[ ! "$mode" =~ ^(DESIGN|PLAN|INVESTIGATE|GUIDE|EXECUTE|TEST|DEBUG|REVIEW|PR-REVIEW)$ ]]; then
            # Shift everything right
            due_offset=$tag
            tag=$description
            description=$mode
            mode=""
        fi

        [[ -z "$description" ]] && error "Task description cannot be empty"
        
        # Format description with mode
        local final_desc="$description"
        if [[ -n "$mode" ]]; then
            final_desc="[$mode] $description"
        fi

        # Set defaults
        tag=${tag:-implementation}
        due_offset=${due_offset:-today}
        
        # Build task command with priority based on position
        local priority="M"
        if (( $(echo "$urgency >= 9.0" | bc -l) )); then
            priority="H"
        elif (( $(echo "$urgency <= 3.0" | bc -l) )); then
            priority="L"
        fi
        
        local cmd="task add project:$initiative \"$final_desc\" due:$due_offset priority:$priority +$tag"
        
        # Add dependency if not first task
        [[ -n "$prev_id" ]] && cmd="$cmd depends:$prev_id"
        
        # Execute and capture ID
        local output
        output=$(eval "$cmd" 2>&1)
        local new_id
        new_id=$(echo "$output" | grep -oP 'Created task \K\d+' || echo "")
        
        if [[ -n "$new_id" ]]; then
            task_ids+=("$new_id")
            success "Created task $new_id: $final_desc [priority: $priority]"
            prev_id="$new_id"
        else
            error "Failed to create task: $final_desc"
        fi
        
        # Decrease urgency for next task
        urgency=$(echo "$urgency - 2.0" | bc)
    done
    
    echo ""
    success "Initiative created with ${#task_ids[@]} tasks"
    info "Task IDs: ${task_ids[*]}"
    info "First task ready to work: ${task_ids[0]}"
}

# Command: next - Show next task(s) ready to work
cmd_next() {
    local filter="${1:-status:pending}"
    
    if [[ "$filter" != status:* ]] && [[ "$filter" != project:* ]]; then
        filter="project:$filter status:pending"
    fi
    
    info "Next tasks ready to work:"
    echo ""
    
    task "$filter" ready 2>/dev/null || warning "No tasks ready"
}

# Command: execute - Start working on a task
cmd_execute() {
    local input_id="$1"
    local task_id
    task_id=$(resolve_uuid "$input_id")
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Check if task is blocked
    local status
    status=$(task "$task_id" export 2>/dev/null | jq -r '.[0].status // "notfound"')
    
    [[ "$status" == "notfound" ]] && error "Task $task_id not found"
    
    local tags
    tags=$(task "$task_id" export 2>/dev/null | jq -r '.[0].tags // [] | join(" ")')
    
    if [[ "$tags" == *"BLOCKED"* ]]; then
        error "Task $task_id is BLOCKED by dependencies"
    fi
    
    task "$task_id" start
    success "Started working on task $(short_id "$task_id")"
    
    # Show task info
    echo ""
    task "$task_id"
}

# Validate that task has OUTCOME annotation
validate_outcome() {
    local task_id="$1"
    
    if task "$task_id" info 2>/dev/null | grep -qi "OUTCOME:"; then
        return 0
    else
        error "Task $task_id cannot be completed without OUTCOME\n   Add outcome first: tw-flow outcome $task_id \"description\" or taskp $task_id annotate \"OUTCOME: description\""
    fi
}

# Command: done - Complete a task
cmd_done() {
    local task_id="$1"
    local note="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Validate outcome before completing
    validate_outcome "$task_id" || exit 1
    
    # Add completion note if provided
    if [[ -n "$note" ]]; then
        task "$task_id" annotate "DONE: $note"
    fi
    
    task "$task_id" done
    success "Task $task_id completed!"
    
    # Check if any tasks were unblocked
    echo ""
    info "Checking for newly unblocked tasks..."
    local unblocked
    unblocked=$(task status:pending ready 2>/dev/null | grep -c "^[0-9]" || echo "0")
    
    if [[ "$unblocked" -gt 0 ]]; then
        success "$unblocked task(s) now ready to work"
        task status:pending ready limit:3
    fi
}

# Command: pause - Pause work on a task
cmd_pause() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    task "$task_id" stop
    success "Paused task $(short_id "$task_id")"
}

# Command: outcome - Record final outcome
cmd_outcome() {
    local task_id="$1"
    shift
    local message="$*"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$message" ]] && error "Outcome message required"
    
    task "$task_id" annotate "OUTCOME: $message"
    success "Recorded outcome for task $(short_id "$task_id")"
}

# Command: handoff - Start next task and add handoff note
cmd_handoff() {
    local task_id="$1"
    shift
    local message="$*"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$message" ]] && error "Handoff message required"
    
    # Execute the next task
    cmd_execute "$task_id"
    
    # Add the handoff note
    task "$task_id" annotate "HANDOFF: $message"
    success "Handoff to task $task_id with note"
}

# Command: note - Add structured annotation
cmd_note() {
    local task_id="$1"
    local type="$2"
    shift 2
    local message="$*"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$type" ]] && error "Note type required (research, decision, blocked, lesson, ac, note, link)"
    [[ -z "$message" ]] && error "Note message required"
    
    # Convert type to uppercase prefix
    local prefix
    case "$type" in
        research|r)   prefix="RESEARCH" ;;
        decision|d)   prefix="DECISION" ;;
        blocked|b)    prefix="BLOCKED" ;;
        lesson|l)     prefix="LESSON" ;;
        ac|a)         prefix="AC" ;;
        note|n)       prefix="NOTE" ;;
        link)         prefix="LINK" ;;
        *)            error "Invalid note type: $type" ;;
    esac
    
    task "$task_id" annotate "$prefix: $message"
    success "Added $prefix note to task $task_id"
}

# Command: context - Show full task context
cmd_context() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    info "Full context for task $task_id:"
    echo ""
    task "$task_id" info
}

# Command: status - Show initiative status overview
cmd_status() {
    local filter="${1:-status:pending}"
    
    if [[ "$filter" != status:* ]] && [[ "$filter" != project:* ]]; then
        filter="project:$filter"
    fi
 
    # Custom initiative status output
    local initiative_name
    initiative_name=$(echo "$filter" | cut -d":" -f2)
    local tasks_list
    tasks_list=$(task "$filter" status:pending export | jq -r '.[] | {uuid: .uuid, id: .id, active: (.status=="pending" and .start!=null), desc: .description} | @base64')
    local total
    total=$(echo "$tasks_list" | wc -l)
    local active_uuid
    active_uuid=$(echo "$tasks_list" | base64 -d | jq -r 'select(.active==true) | .uuid' | head -n1)
    local next_uuid
    next_uuid=$(echo "$tasks_list" | base64 -d | jq -r 'select(.active!=true) | .uuid' | head -n1)
    echo -e "${CYAN}Initiative: $initiative_name${NC}"
    n=1
    echo "$tasks_list" | while read -r task; do
        t=$(echo "$task" | base64 -d)
        uuid=$(echo "$t" | jq -r '.uuid')
        
        short_uuid=$(short_id "$uuid")
        desc=$(echo "$t" | jq -r '.desc')
        if [[ "$uuid" == "$active_uuid" ]]; then
            echo -e "- ✓ [$short_uuid - ATIVA] $desc"
        else
            echo -e "- [$short_uuid] $desc"
        fi
        n=$((n+1))
    done
    echo -e "\nTotal: $total tarefas. Tarefa ativa: $(short_id "$active_uuid"). Próxima: $(short_id "$next_uuid").\n"
    
    # Count tasks by status
    local pending blocked active completed
    pending=$(task "$filter" status:pending 2>/dev/null | grep -c "^[0-9]" || echo "0")
    blocked=$(task "$filter" +BLOCKED 2>/dev/null | grep -c "^[0-9]" || echo "0")
    active=$(task "$filter" +ACTIVE 2>/dev/null | grep -c "^[0-9]" || echo "0")
    completed=$(task "$filter" status:completed 2>/dev/null | grep -c "^[0-9]" || echo "0")
    
    echo -e "${GREEN}Completed:${NC} $completed"
    echo -e "${BLUE}Active:${NC} $active"
    echo -e "${YELLOW}Blocked:${NC} $blocked"
    echo -e "${CYAN}Pending:${NC} $pending"
    echo ""
    
    # Show task list
    if [[ "$pending" -gt 0 ]]; then
        info "Pending tasks:"
        task "$filter" status:pending
    else
        success "No pending tasks!"
    fi
}

# Command: initiatives - List all initiatives with pending tasks
cmd_initiatives() {
    info "Initiatives with pending tasks:"
    echo ""
    
    local initiatives
    initiatives=$(task status:pending export | jq -r '.[].project' | sort | uniq)
    
    if [[ -z "$initiatives" ]]; then
        success "No active initiatives!"
        return
    fi
    
    while IFS= read -r initiative; do
        [[ -z "$initiative" ]] && continue
        local pending
        pending=$(task "project:$initiative" status:pending 2>/dev/null | grep -c "^[0-9]" || echo "0")
        local active
        active=$(task "project:$initiative" +ACTIVE 2>/dev/null | grep -c "^[0-9]" || echo "0")
        local blocked
        blocked=$(task "project:$initiative" +BLOCKED 2>/dev/null | grep -c "^[0-9]" || echo "0")
        
        echo -e "${CYAN}● $plan${NC}"
        echo -e "  Pending: $pending | Active: $active | Blocked: $blocked"
        echo ""
    done <<< "$initiatives"
}

# Command: active - Show currently active tasks
cmd_active() {
    info "Currently active tasks:"
    echo ""
    task +ACTIVE 2>/dev/null || warning "No active tasks"
}

# Command: blocked - Show blocked tasks
cmd_blocked() {
    info "Blocked tasks:"
    echo ""
    task +BLOCKED 2>/dev/null || success "No blocked tasks"
}

# Command: overdue - Show overdue tasks
cmd_overdue() {
    info "Overdue tasks:"
    echo ""
    task due.before:today status:pending 2>/dev/null || success "No overdue tasks"
}

# Command: urgent - Make task urgent
cmd_urgent() {
    local task_id="$1"
    local urgency="${2:-15.0}"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    task "$task_id" modify "urgency:$urgency" priority:H
    success "Task $task_id marked as urgent (urgency: $urgency)"
}

# Command: block - Add dependency
cmd_block() {
    local task_id="$1"
    local depends_on="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$depends_on" ]] && error "Dependency task ID required"
    
    task "$task_id" modify "depends:$depends_on"
    success "Task $task_id now depends on task $depends_on"
}

# Command: unblock - Remove dependency
cmd_unblock() {
    local task_id="$1"
    local depends_on="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$depends_on" ]] && error "Dependency task ID required"
    
    # Get current dependencies
    local current_deps
    current_deps=$(task "$task_id" export | jq -r '.[0].depends // [] | join(",")')
    
    # Remove the specific dependency
    local new_deps
    new_deps=$(echo "$current_deps" | tr ',' '\n' | grep -v "^$depends_on$" | tr '\n' ',' | sed 's/,$//')
    
    if [[ -n "$new_deps" ]]; then
        task "$task_id" modify "depends:$new_deps"
    else
        task "$task_id" modify depends:
    fi
    
    success "Removed dependency on task $depends_on from task $task_id"
}

# Command: wait - Put task on hold
cmd_wait() {
    local task_id="$1"
    local date="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$date" ]] && error "Wait date required (e.g., friday, 2026-02-01)"
    
    task "$task_id" modify "wait:$date"
    success "Task $task_id waiting until $date"
}

# Main command dispatcher
main() {
    [[ $# -eq 0 ]] && { show_usage; exit 0; }
    
    local command="$1"
    shift
    
    case "$command" in
        initiative|ini)       cmd_initiative "$@" ;;
        initiatives|inis)      cmd_initiatives "$@" ;;
        next)       cmd_next "$@" ;;
        execute)    cmd_execute "$@" ;;
        done)       cmd_done "$@" ;;
        outcome)    cmd_outcome "$@" ;;
        handoff)    cmd_handoff "$@" ;;
        pause)      cmd_pause "$@" ;;
        note)       cmd_note "$@" ;;
        context)    cmd_context "$@" ;;
        status)     cmd_status "$@" ;;
        active)     cmd_active "$@" ;;
        blocked)    cmd_blocked "$@" ;;
        overdue)    cmd_overdue "$@" ;;
        urgent)     cmd_urgent "$@" ;;
        block)      cmd_block "$@" ;;
        unblock)    cmd_unblock "$@" ;;
        wait)       cmd_wait "$@" ;;
        help|-h|--help) show_usage ;;
        *)          error "Unknown command: $command (use '$SCRIPT_NAME help' for usage)" ;;
    esac
}

main "$@"
