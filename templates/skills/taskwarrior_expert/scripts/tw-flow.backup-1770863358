#!/bin/bash
# Taskwarrior Flow - Imperative commands for task management
# Makes Taskwarrior easier to use for AI agents

set -e

SCRIPT_NAME="tw-flow"
VERSION="1.3.0"

# Detect project and set TASKDATA if PROJECT_ID is available
detect_and_set_taskdata() {
    if [ -n "$PROJECT_ID" ]; then
        export TASKDATA="$HOME/.task/$PROJECT_ID"
        mkdir -p "$TASKDATA"
    fi
}

# Set TASKDATA before doing anything
detect_and_set_taskdata

# Helper functions
error() {
    echo -e "ERROR: $1" >&2
    exit 1
}

success() {
    echo -e "‚úì $1"
}

info() {
    echo -e "‚Ñπ $1"
}

warning() {
    echo -e "‚ö† $1"
}

# Helper: Shorten UUID for display (8 chars)
short_id() {
    local id="$1"
    if [[ "$id" =~ ^[0-9a-fA-F-]{8,}$ ]]; then
        echo "${id:0:8}"
    else
        echo "$id"
    fi
}

# Helper: Resolve UUID (expand short UUID or validate full UUID)
resolve_uuid() {
    local input="$1"
    
    # If it's already a full UUID (36 chars with dashes), return it
    if [[ "$input" =~ ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$ ]]; then
        echo "$input"
        return 0
    fi
    
    # If it's a short UUID (8 chars), find the matching task
    if [[ "$input" =~ ^[0-9a-fA-F]{8}$ ]]; then
        local full_uuid
        full_uuid=$(task export 2>/dev/null | jq -r ".[] | select(.uuid | startswith(\"$input\")) | .uuid" | head -1)
        if [[ -n "$full_uuid" ]]; then
            echo "$full_uuid"
            return 0
        fi
    fi
    
    # Otherwise, assume it's a valid identifier and return as-is
    echo "$input"
}



show_usage() {
    cat <<EOF
Taskwarrior Flow - Simplified task management commands

USAGE:
    $SCRIPT_NAME <command> [options]

COMMANDS:

  Initiatives:
    initiative|ini <initiative> <tasks...>    Create a new initiative with multiple tasks
                                       Tasks format: "mode|description|tag|due_offset"
                                       Modes: DESIGN, INVESTIGATE, GUIDE, EXECUTE, TEST, DEBUG, REVIEW, PR-REVIEW
    
  Execution:
    next [initiative]                Show next task(s) ready to work
    execute <id>                       Start working on a task
    done <id> [note]                   Complete a task with optional note
    outcome <id> <message>             Record final outcome before closing
    handoff <id> <message>             Start next task and add handoff note
    pause <id>                         Pause work on a task
    
  Context:
    note <id> <type> <message>         Add structured annotation
                                       Types: research, decision, blocked, lesson, ac, note, link
    context <id>                       Show full task context (annotations, deps, etc.)
    
  Viewing:
    initiatives|inis                              List all initiatives with pending tasks
    status [initiative]              Show initiative status overview
    active                             Show currently active tasks
    blocked                            Show blocked tasks
    overdue                            Show overdue tasks
    
  Modifications:
    urgent <id> [urgency]              Make task urgent (default: 15.0)
    block <id> <depends_on_id>         Add dependency to task
    unblock <id> <depends_on_id>       Remove dependency from task
    wait <id> <date>                   Put task on hold until date
    discard <id>                       Soft delete - move to trash and mark done
    tree [project]                     Show visual dependency tree
    discard <id>                       Soft delete - move to trash and mark done

EXAMPLES:

  # Create a 3-task initiative with modes
  $SCRIPT_NAME initiative login-feature \\
    "DESIGN|Design auth flow|research|today" \\
    "EXECUTE|Implement JWT|implementation|tomorrow" \\
    "TEST|Write tests|testing|2days"

  # See what's next
  $SCRIPT_NAME next login-feature

  # Start working
  $SCRIPT_NAME execute 42

  # Add research note
  $SCRIPT_NAME note 42 research "Found passport.js library"

  # Record outcome
  $SCRIPT_NAME outcome 42 "Implemented OAuth login flow"

  # Complete task
  $SCRIPT_NAME done 42

  # Handoff to next task
  $SCRIPT_NAME handoff 43 "Pick up implementation. See Task 42 for design docs."

  # Check status
  $SCRIPT_NAME status login-feature
  $SCRIPT_NAME done 42 "Completed design phase"

  # Check status
  $SCRIPT_NAME status login-feature

EOF
}

# Command: initiative - Create a new initiative with tasks
cmd_initiative() {
    local initiative="$1"
    shift
    
    [[ -z "$initiative" ]] && error "Initiative name required"
    [[ $# -eq 0 ]] && error "At least one task required"
    
    info "Creating initiative: $initiative"
    
    local urgency=9.0
    local task_ids=()
    local prev_id=""
    
    for task_spec in "$@"; do
        # Parse mode|description|tag|due_offset
        IFS='|' read -r mode description tag due_offset <<< "$task_spec"
        
        # If the first field isn't a known mode, assume the old format (description|tag|due)
        # or that mode was omitted.
        if [[ ! "$mode" =~ ^(DESIGN|PLAN|INVESTIGATE|GUIDE|EXECUTE|TEST|DEBUG|REVIEW|PR-REVIEW)$ ]]; then
            # Shift everything right
            due_offset=$tag
            tag=$description
            description=$mode
            mode=""
        fi

        [[ -z "$description" ]] && error "Task description cannot be empty"
        
        # Format description with mode
        local final_desc="$description"
        if [[ -n "$mode" ]]; then
            final_desc="[$mode] $description"
        fi

        # Set defaults
        tag=${tag:-implementation}
        due_offset=${due_offset:-today}
        
        # Build task command with priority based on position
        local priority="M"
        if (( $(echo "$urgency >= 9.0" | bc -l) )); then
            priority="H"
        elif (( $(echo "$urgency <= 3.0" | bc -l) )); then
            priority="L"
        fi
        
        local cmd="task add project:$initiative \"$final_desc\" due:$due_offset priority:$priority +$tag"
        
        # Add dependency if not first task
        [[ -n "$prev_id" ]] && cmd="$cmd depends:$prev_id"
        
        # Execute and capture ID
        local output
        output=$(eval "$cmd" 2>&1)
        local new_id
        new_id=$(echo "$output" | grep -oP 'Created task \K\d+' || echo "")
        
        if [[ -n "$new_id" ]]; then
            task_ids+=("$new_id")
            success "Created task $new_id: $final_desc [priority: $priority]"
            prev_id="$new_id"
        else
            error "Failed to create task: $final_desc"
        fi
        
        # Decrease urgency for next task
        urgency=$(echo "$urgency - 2.0" | bc)
    done
    
    echo ""
    success "Initiative created with ${#task_ids[@]} tasks"
    info "Task IDs: ${task_ids[*]}"
    info "First task ready to work: ${task_ids[0]}"
}

# Command: next - Show next task(s) ready to work
cmd_next() {
    local filter="${1:-status:pending}"
    
    if [[ "$filter" != status:* ]] && [[ "$filter" != * ]]; then
        filter="$filter status:pending"
    fi
    
    info "Next tasks ready to work:"
    echo ""
    
    task "$filter" ready 2>/dev/null || warning "No tasks ready"
}

# Helper: Get inherited context from parent tasks (dependencies)
get_parent_context() {
    local task_id="$1"
    local json
    json=$(task "$task_id" export 2>/dev/null | jq '.[0]')
    
    # UUIDs of dependencies
    local deps
    deps=$(echo "$json" | jq -r '.depends // [] | join(" ")')
    
    if [[ -n "$deps" ]]; then
        local found_context=false
        for dep_uuid in $deps; do
            local dep_json
            dep_json=$(task "$dep_uuid" export 2>/dev/null | jq '.[0]')
            [[ -z "$dep_json" || "$dep_json" == "null" ]] && continue
            
            local dep_desc=$(echo "$dep_json" | jq -r '.description')
            local uuid=$(echo "$dep_json" | jq -r '.uuid')
            
            # Extract relevant annotations
            local annotations
            annotations=$(echo "$dep_json" | jq -r '.annotations // [] | .[] | select(.description | test("^(OUTCOME|DECISION|LESSON|HANDOFF):")) | .description')
            
            if [[ -n "$annotations" ]]; then
                if [[ "$found_context" == false ]]; then
                    echo -e "\n‚ïê‚ïê INHERITED CONTEXT ‚ïê‚ïê"
                    found_context=true
                fi
                echo -e "Task (${uuid:0:8}) [$dep_desc]:"
                echo "$annotations" | sed 's/^/  - /'
            fi
        done
        [[ "$found_context" == true ]] && echo ""
    fi
}

# Command: execute - Start working on a task
cmd_execute() {
    local input_id="$1"
    local task_id
    task_id=$(resolve_uuid "$input_id")
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Check if task is blocked
    local status
    status=$(task "$task_id" export 2>/dev/null | jq -r '.[0].status // "notfound"')
    
    [[ "$status" == "notfound" ]] && error "Task $task_id not found"
    
    local tags
    tags=$(task "$task_id" export 2>/dev/null | jq -r '.[0].tags // [] | join(" ")')
    
    if [[ "$tags" == *"BLOCKED"* ]]; then
        error "Task $task_id is BLOCKED by dependencies"
    fi
    
    # Show inherited context from dependencies
    get_parent_context "$task_id"

    task "$task_id" start
    success "Started working on task $(short_id "$task_id")"
    
    # Show task info
    echo ""
    task "$task_id"
}

# Validate that task has OUTCOME annotation
validate_outcome() {
    local task_id="$1"
    
    if task "$task_id" info 2>/dev/null | grep -qi "OUTCOME:"; then
        return 0
    else
        error "Task $task_id cannot be completed without OUTCOME\n   Add outcome first: tw-flow outcome $task_id \"description\" or taskp $task_id annotate \"OUTCOME: description\""
    fi
}

# Command: done - Complete a task
cmd_done() {
    local task_id="$1"
    local note="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Validate outcome before completing
    validate_outcome "$task_id" || exit 1
    
    # Add completion note if provided
    if [[ -n "$note" ]]; then
        task "$task_id" annotate "DONE: $note"
    fi
    
    task "$task_id" done
    success "Task $task_id completed!"
    
    # Check if any tasks were unblocked
    echo ""
    info "Checking for newly unblocked tasks..."
    local unblocked
    unblocked=$(task status:pending ready 2>/dev/null | grep -c "^[0-9]" || echo "0")
    
    if [[ "$unblocked" -gt 0 ]]; then
        success "$unblocked task(s) now ready to work"
        task status:pending ready limit:3
    fi
}

# Command: pause - Pause work on a task
cmd_pause() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    task "$task_id" stop
    success "Paused task $(short_id "$task_id")"
}

# Command: outcome - Record final outcome
cmd_outcome() {
    local task_id="$1"
    shift
    local message="$*"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$message" ]] && error "Outcome message required"
    
    task "$task_id" annotate "OUTCOME: $message"
    success "Recorded outcome for task $(short_id "$task_id")"
}

# Command: handoff - Start next task and add handoff note
cmd_handoff() {
    local task_id="$1"
    shift
    local message="$*"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$message" ]] && error "Handoff message required"
    
    # Execute the next task
    cmd_execute "$task_id"
    
    # Add the handoff note
    task "$task_id" annotate "HANDOFF: $message"
    success "Handoff to task $task_id with note"
}

# Command: note - Add structured annotation
cmd_note() {
    local task_id="$1"
    local type="$2"
    shift 2
    local message="$*"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$type" ]] && error "Note type required (research, decision, blocked, lesson, ac, note, link)"
    [[ -z "$message" ]] && error "Note message required"
    
    # Convert type to uppercase prefix
    local prefix
    case "$type" in
        research|r)   prefix="RESEARCH" ;;
        decision|d)   prefix="DECISION" ;;
        blocked|b)    prefix="BLOCKED" ;;
        lesson|l)     prefix="LESSON" ;;
        ac|a)         prefix="AC" ;;
        note|n)       prefix="NOTE" ;;
        link)         prefix="LINK" ;;
        *)            error "Invalid note type: $type" ;;
    esac
    
    task "$task_id" annotate "$prefix: $message"
    success "Added $prefix note to task $task_id"
}

# Command: context - Show full task context
cmd_context() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Resolve UUID if short UUID provided
    task_id=$(resolve_uuid "$task_id")
 
    info "Full context for task $task_id:"
    echo ""
    task "$task_id" info
}

# Command: status - Show initiative status overview
cmd_status() {
    local filter="${1:-status:pending}"
    
    if [[ "$filter" != status:* ]] && [[ "$filter" != * ]]; then
        filter="$filter"
    fi
 
    # Custom initiative status output
    local initiative_name
    initiative_name=$(echo "$filter" | cut -d":" -f2)
    local tasks_list
    tasks_list=$(task "$filter" status:pending export | jq -r '.[] | {uuid: .uuid, id: .id, active: (.status=="pending" and .start!=null), desc: .description} | @base64')
    local total
    total=$(echo "$tasks_list" | wc -l)
    local active_uuid
    active_uuid=$(echo "$tasks_list" | base64 -d | jq -r 'select(.active==true) | .uuid' | head -n1)
    local next_uuid
    next_uuid=$(echo "$tasks_list" | base64 -d | jq -r 'select(.active!=true) | .uuid' | head -n1)
    echo -e "Initiative: $initiative_name"
    n=1
    echo "$tasks_list" | while read -r task; do
        t=$(echo "$task" | base64 -d)
        uuid=$(echo "$t" | jq -r '.uuid')
        
        short_uuid=$(short_id "$uuid")
        desc=$(echo "$t" | jq -r '.desc')
        if [[ "$uuid" == "$active_uuid" ]]; then
            echo -e "- ‚úì [$short_uuid - ATIVA] $desc"
        else
            echo -e "- [$short_uuid] $desc"
        fi
        n=$((n+1))
    done
    echo -e "\nTotal: $total tarefas. Tarefa ativa: $(short_id "$active_uuid"). Pr√≥xima: $(short_id "$next_uuid").\n"
    
    # Count tasks by status
    local pending blocked active completed
    pending=$(task "$filter" status:pending 2>/dev/null | grep -c "^[0-9]" || echo "0")
    blocked=$(task "$filter" +BLOCKED 2>/dev/null | grep -c "^[0-9]" || echo "0")
    active=$(task "$filter" +ACTIVE 2>/dev/null | grep -c "^[0-9]" || echo "0")
    completed=$(task "$filter" status:completed 2>/dev/null | grep -c "^[0-9]" || echo "0")
    
    echo -e "Completed: $completed"
    echo -e "Active: $active"
    echo -e "Blocked: $blocked"
    echo -e "Pending: $pending"
    echo ""
    
    # Show task list
    if [[ "$pending" -gt 0 ]]; then
        info "Pending tasks:"
        task "$filter" status:pending
    else
        success "No pending tasks!"
    fi
}

# Command: initiatives - List all initiatives with pending tasks
cmd_initiatives() {
    info "Initiatives with pending tasks:"
    echo ""
    
    local initiatives
    initiatives=$(task status:pending export | jq -r '.[].project' | sort | uniq)
    
    if [[ -z "$initiatives" ]]; then
        success "No active initiatives!"
        return
    fi
    
    while IFS= read -r initiative; do
        [[ -z "$initiative" ]] && continue
        local pending
        pending=$(task "$initiative" status:pending 2>/dev/null | grep -c "^[0-9]" || echo "0")
        local active
        active=$(task "$initiative" +ACTIVE 2>/dev/null | grep -c "^[0-9]" || echo "0")
        local blocked
        blocked=$(task "$initiative" +BLOCKED 2>/dev/null | grep -c "^[0-9]" || echo "0")
        
        echo -e "‚óè $plan"
        echo -e "  Pending: $pending | Active: $active | Blocked: $blocked"
        echo ""
    done <<< "$initiatives"
}

# Command: active - Show currently active tasks
cmd_active() {
    info "Currently active tasks:"
    echo ""
    task +ACTIVE 2>/dev/null || warning "No active tasks"
}

# Command: blocked - Show blocked tasks
cmd_blocked() {
    info "Blocked tasks:"
    echo ""
    task +BLOCKED 2>/dev/null || success "No blocked tasks"
}

# Command: overdue - Show overdue tasks
cmd_overdue() {
    info "Overdue tasks:"
    echo ""
    task due.before:today status:pending 2>/dev/null || success "No overdue tasks"
}

# Command: urgent - Make task urgent
cmd_urgent() {
    local task_id="$1"
    local urgency="${2:-15.0}"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    task "$task_id" modify "urgency:$urgency" priority:H
    success "Task $task_id marked as urgent (urgency: $urgency)"
}

# Command: block - Add dependency
cmd_block() {
    local task_id="$1"
    local depends_on="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$depends_on" ]] && error "Dependency task ID required"
    
    task "$task_id" modify "depends:$depends_on"
    success "Task $task_id now depends on task $depends_on"
}

# Command: unblock - Remove dependency
cmd_unblock() {
    local task_id="$1"
    local depends_on="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$depends_on" ]] && error "Dependency task ID required"
    
    # Get current dependencies
    local current_deps
    current_deps=$(task "$task_id" export | jq -r '.[0].depends // [] | join(",")')
    
    # Remove the specific dependency
    local new_deps
    new_deps=$(echo "$current_deps" | tr ',' '\n' | grep -v "^$depends_on$" | tr '\n' ',' | sed 's/,$//')
    
    if [[ -n "$new_deps" ]]; then
        task "$task_id" modify "depends:$new_deps"
    else
        task "$task_id" modify depends:
    fi
    
    success "Removed dependency on task $depends_on from task $task_id"
}

# Command: wait - Put task on hold
cmd_wait() {
    local task_id="$1"
    local date="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$date" ]] && error "Wait date required (e.g., friday, 2026-02-01)"
    
    task "$task_id" modify "wait:$date"
    success "Task $task_id waiting until $date"
}

# Soft delete - move task to trash
cmd_discard() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Get current project to preserve context in trash
    local current_project
    current_project=$(task "$task_id" export 2>/dev/null | jq -r '.[0].project // "unscoped"')
    
    # Move to trash project (ensure we don't double trash)
    local trash_project="$current_project"
    if [[ "$current_project" != *":trash" ]]; then
        trash_project="$current_project:trash"
    fi
    
    task "$task_id" modify project:"$trash_project" +DISCARDED
    task "$task_id" done
    
    success "Task $(short_id "$task_id") moved to trash and marked done."
}



cmd_tree() {
    local filter="${1:-status:pending}"
    if [[ "$filter" != status:* ]] && [[ "$filter" != * ]]; then
        filter="$filter"
    fi

    local project_name
    project_name=$(echo "$filter" | sed 's/^//')
    echo -e "‚ïê‚ïê Initiative: $project_name ‚ïê‚ïê"

    # Helper for recursive tree rendering
    render_tree_node() {
        local uuid="$1"
        local indent="$2"
        local is_last="$3"

        local json
        json=$(task "$uuid" export 2>/dev/null | jq '.[0]')
        [[ -z "$json" || "$json" == "null" ]] && return

        local desc=$(echo "$json" | jq -r '.description')
        local status=$(echo "$json" | jq -r '.status')
        local start=$(echo "$json" | jq -r '.start // ""')

        local icon="‚óã"
        [[ "$status" == "completed" ]] && icon="‚úì"
        [[ -n "$start" ]] && icon="‚ö°"
        
        # Check if blocked
        local is_ready
        is_ready=$(task "$uuid" +READY export 2>/dev/null | jq -r '.[0].id // ""')
        if [[ "$status" == "pending" && -z "$is_ready" ]]; then
            icon="üîí"
        fi

        local marker="‚îú‚îÄ‚îÄ"
        [[ "$is_last" == "true" ]] && marker="‚îî‚îÄ‚îÄ"
        [[ -z "$indent" ]] && marker=""

        printf "%b%b %b (%s) | %s\n" "$indent" "$marker" "$icon" "${uuid:0:8}" "$desc"

        # Find children (tasks that depend on this one)
        local children
        children=$(task "depends.contains:$uuid" status:pending export 2>/dev/null | jq -r '.[] | select(.project | test("_archive$|_trash$") | not) | .uuid' || echo "")
        
        local child_indent="$indent    "
        [[ "$marker" == "‚îú‚îÄ‚îÄ" ]] && child_indent="$indent‚îÇ   "
        [[ -z "$indent" ]] && child_indent=""

        local count
        count=$(echo "$children" | grep -c . || echo 0)
        local i=1
        while read -r child_uuid; do
            [[ -z "$child_uuid" ]] && continue
            local last_child="false"
            [[ "$i" -eq "$count" ]] && last_child="true"
            render_tree_node "$child_uuid" "$child_indent" "$last_child"
            i=$((i+1))
        done <<< "$children"
    }

    # Find root nodes (tasks in project with no dependencies or whose dependencies are outside this project/completed)
    local root_uuids
    root_uuids=$(task "$filter" export 2>/dev/null | jq -r '.[] | select(.project | test("_archive$|_trash$") | not) | select(.depends == null or (.depends | length == 0)) | .uuid')

    if [[ -z "$root_uuids" ]]; then
        # If no strict roots, just show all tasks in project as a list for now
        task "$filter" export 2>/dev/null | jq -r '.[] | select(.project | test("_archive$|_trash$") | not) | .uuid' | while read -r uuid; do
             [[ -n "$uuid" ]] && render_tree_node "$uuid" "" "false"
        done
    else
        while read -r uuid; do
            [[ -n "$uuid" ]] && render_tree_node "$uuid" "" "false"
        done <<< "$root_uuids"
    fi
}

# Main command dispatcher
main() {
    [[ $# -eq 0 ]] && { show_usage; exit 0; }
    
    local command="$1"
    shift
    
    case "$command" in
        initiative|ini)       cmd_initiative "$@" ;;
        initiatives|inis)      cmd_initiatives "$@" ;;
        next)       cmd_next "$@" ;;
        execute)    cmd_execute "$@" ;;
        done)       cmd_done "$@" ;;
        outcome)    cmd_outcome "$@" ;;
        handoff)    cmd_handoff "$@" ;;
        pause)      cmd_pause "$@" ;;
        note)       cmd_note "$@" ;;
        context)    cmd_context "$@" ;;
        status)     cmd_status "$@" ;;
        active)     cmd_active "$@" ;;
        blocked)    cmd_blocked "$@" ;;
        overdue)    cmd_overdue "$@" ;;
        urgent)     cmd_urgent "$@" ;;
        block)      cmd_block "$@" ;;
        unblock)    cmd_unblock "$@" ;;
        wait)       cmd_wait "$@" ;;
        discard)    cmd_discard "$@" ;;
        tree)       cmd_tree "$@" ;;
        help|-h|--help) show_usage ;;
        *)          error "Unknown command: $command (use '$SCRIPT_NAME help' for usage)" ;;
    esac
}

main "$@"
