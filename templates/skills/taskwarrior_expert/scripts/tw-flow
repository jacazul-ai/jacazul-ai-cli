#!/bin/bash
# Taskwarrior Flow - Imperative commands for task management
# Makes Taskwarrior easier to use for AI agents

set -e

SCRIPT_NAME="tw-flow"
VERSION="1.0.0"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Helper functions
error() {
    echo -e "${RED}ERROR:${NC} $1" >&2
    exit 1
}

success() {
    echo -e "${GREEN}✓${NC} $1"
}

info() {
    echo -e "${CYAN}ℹ${NC} $1"
}

warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

show_usage() {
    cat <<EOF
${CYAN}Taskwarrior Flow${NC} - Simplified task management commands

${YELLOW}USAGE:${NC}
    $SCRIPT_NAME <command> [options]

${YELLOW}COMMANDS:${NC}

  ${GREEN}Planning:${NC}
    plan <project:plan> <tasks...>    Create a new plan with multiple tasks
                                       Tasks format: "description|tag|due_offset"
    
  ${GREEN}Execution:${NC}
    next [project:plan]                Show next task(s) ready to work
    execute <id>                       Start working on a task
    done <id> [note]                   Complete a task with optional note
    pause <id>                         Pause work on a task
    
  ${GREEN}Context:${NC}
    note <id> <type> <message>         Add structured annotation
                                       Types: research, decision, blocked, lesson, ac, note, link
    context <id>                       Show full task context (annotations, deps, etc.)
    
  ${GREEN}Viewing:${NC}
    plans                              List all plans with pending tasks
    status [project:plan]              Show plan status overview
    active                             Show currently active tasks
    blocked                            Show blocked tasks
    overdue                            Show overdue tasks
    
  ${GREEN}Modifications:${NC}
    urgent <id> [urgency]              Make task urgent (default: 15.0)
    block <id> <depends_on_id>         Add dependency to task
    unblock <id> <depends_on_id>       Remove dependency from task
    wait <id> <date>                   Put task on hold until date

${YELLOW}EXAMPLES:${NC}

  # Create a 3-task plan
  $SCRIPT_NAME plan copilot:login-feature \\
    "Design auth flow|research|today" \\
    "Implement JWT|implementation|tomorrow" \\
    "Write tests|testing|2days"

  # See what's next
  $SCRIPT_NAME next copilot:login-feature

  # Start working
  $SCRIPT_NAME execute 42

  # Add research note
  $SCRIPT_NAME note 42 research "Found passport.js library"

  # Complete task
  $SCRIPT_NAME done 42 "Completed design phase"

  # Check status
  $SCRIPT_NAME status copilot:login-feature

EOF
}

# Command: plan - Create a new plan with tasks
cmd_plan() {
    local project_plan="$1"
    shift
    
    [[ -z "$project_plan" ]] && error "Project:plan name required"
    [[ $# -eq 0 ]] && error "At least one task required"
    
    info "Creating plan: $project_plan"
    
    local urgency=9.0
    local task_ids=()
    local prev_id=""
    
    for task_spec in "$@"; do
        IFS='|' read -r description tag due_offset <<< "$task_spec"
        
        [[ -z "$description" ]] && error "Task description cannot be empty"
        
        # Set defaults
        tag=${tag:-implementation}
        due_offset=${due_offset:-today}
        
        # Build task command with priority based on position
        local priority="M"
        if (( $(echo "$urgency >= 9.0" | bc -l) )); then
            priority="H"
        elif (( $(echo "$urgency <= 3.0" | bc -l) )); then
            priority="L"
        fi
        
        local cmd="task add project:$project_plan \"$description\" due:$due_offset priority:$priority +$tag"
        
        # Add dependency if not first task
        [[ -n "$prev_id" ]] && cmd="$cmd depends:$prev_id"
        
        # Execute and capture ID
        local output
        output=$(eval "$cmd" 2>&1)
        local new_id
        new_id=$(echo "$output" | grep -oP 'Created task \K\d+' || echo "")
        
        if [[ -n "$new_id" ]]; then
            task_ids+=("$new_id")
            success "Created task $new_id: $description [priority: $priority]"
            prev_id="$new_id"
        else
            error "Failed to create task: $description"
        fi
        
        # Decrease urgency for next task
        urgency=$(echo "$urgency - 2.0" | bc)
    done
    
    echo ""
    success "Plan created with ${#task_ids[@]} tasks"
    info "Task IDs: ${task_ids[*]}"
    info "First task ready to work: ${task_ids[0]}"
}

# Command: next - Show next task(s) ready to work
cmd_next() {
    local filter="${1:-status:pending}"
    
    if [[ "$filter" != status:* ]] && [[ "$filter" != project:* ]]; then
        filter="project:$filter status:pending"
    fi
    
    info "Next tasks ready to work:"
    echo ""
    
    task "$filter" ready 2>/dev/null || warning "No tasks ready"
}

# Command: execute - Start working on a task
cmd_execute() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Check if task is blocked
    local status
    status=$(task "$task_id" export 2>/dev/null | jq -r '.[0].status // "notfound"')
    
    [[ "$status" == "notfound" ]] && error "Task $task_id not found"
    
    local tags
    tags=$(task "$task_id" export 2>/dev/null | jq -r '.[0].tags // [] | join(" ")')
    
    if [[ "$tags" == *"BLOCKED"* ]]; then
        error "Task $task_id is BLOCKED by dependencies"
    fi
    
    task "$task_id" start
    success "Started working on task $task_id"
    
    # Show task info
    echo ""
    task "$task_id"
}

# Command: done - Complete a task
cmd_done() {
    local task_id="$1"
    local note="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Add completion note if provided
    if [[ -n "$note" ]]; then
        task "$task_id" annotate "DONE: $note"
    fi
    
    task "$task_id" done
    success "Task $task_id completed!"
    
    # Check if any tasks were unblocked
    echo ""
    info "Checking for newly unblocked tasks..."
    local unblocked
    unblocked=$(task status:pending ready 2>/dev/null | grep -c "^[0-9]" || echo "0")
    
    if [[ "$unblocked" -gt 0 ]]; then
        success "$unblocked task(s) now ready to work"
        task status:pending ready limit:3
    fi
}

# Command: pause - Pause work on a task
cmd_pause() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    task "$task_id" stop
    success "Paused task $task_id"
}

# Command: note - Add structured annotation
cmd_note() {
    local task_id="$1"
    local type="$2"
    shift 2
    local message="$*"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$type" ]] && error "Note type required (research, decision, blocked, lesson, ac, note, link)"
    [[ -z "$message" ]] && error "Note message required"
    
    # Convert type to uppercase prefix
    local prefix
    case "$type" in
        research|r)   prefix="RESEARCH" ;;
        decision|d)   prefix="DECISION" ;;
        blocked|b)    prefix="BLOCKED" ;;
        lesson|l)     prefix="LESSON" ;;
        ac|a)         prefix="AC" ;;
        note|n)       prefix="NOTE" ;;
        link)         prefix="LINK" ;;
        *)            error "Invalid note type: $type" ;;
    esac
    
    task "$task_id" annotate "$prefix: $message"
    success "Added $prefix note to task $task_id"
}

# Command: context - Show full task context
cmd_context() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    info "Full context for task $task_id:"
    echo ""
    task "$task_id" info
}

# Command: status - Show plan status overview
cmd_status() {
    local filter="${1:-status:pending}"
    
    if [[ "$filter" != status:* ]] && [[ "$filter" != project:* ]]; then
        filter="project:$filter"
    fi
 
    # Custom plan status output
    local plan_name
    plan_name=$(echo "$filter" | cut -d":" -f2)
    local tasks_list
    tasks_list=$(task "$filter" status:pending export | jq -r ".[] | {id: .id, active: (.status==\"pending\" and .start!=null), desc: .description} | @base64")
    local total
    total=$(echo "$tasks_list" | wc -l)
    local active_id
    active_id=$(echo "$tasks_list" | base64 -d | jq -r 'select(.active==true) | .id' | head -n1)
    local next_id
    next_id=$(echo "$tasks_list" | base64 -d | jq -r 'select(.active!=true) | .id' | head -n1)
    echo -e "${CYAN}Plano: $plan_name${NC}"
    n=1
    echo "$tasks_list" | while read -r task; do
        t=$(echo "$task" | base64 -d)
        id=$(echo "$t" | jq -r '.id')
        desc=$(echo "$t" | jq -r '.desc')
        if [[ "$id" == "$active_id" ]]; then
            echo -e "- ✓ [Tarefa $id - ATIVA] $desc"
        else
            echo -e "- [Tarefa $id] $desc"
        fi
        n=$((n+1))
    done
    echo -e "\nTotal: $total tarefas. Tarefa ativa: $active_id. Próxima: $next_id.\n"
    
    # Count tasks by status
    local pending blocked active completed
    pending=$(task "$filter" status:pending 2>/dev/null | grep -c "^[0-9]" || echo "0")
    blocked=$(task "$filter" +BLOCKED 2>/dev/null | grep -c "^[0-9]" || echo "0")
    active=$(task "$filter" +ACTIVE 2>/dev/null | grep -c "^[0-9]" || echo "0")
    completed=$(task "$filter" status:completed 2>/dev/null | grep -c "^[0-9]" || echo "0")
    
    echo -e "${GREEN}Completed:${NC} $completed"
    echo -e "${BLUE}Active:${NC} $active"
    echo -e "${YELLOW}Blocked:${NC} $blocked"
    echo -e "${CYAN}Pending:${NC} $pending"
    echo ""
    
    # Show task list
    if [[ "$pending" -gt 0 ]]; then
        info "Pending tasks:"
        task "$filter" status:pending
    else
        success "No pending tasks!"
    fi
}

# Command: plans - List all plans with pending tasks
cmd_plans() {
    info "Plans with pending tasks:"
    echo ""
    
    local plans
    plans=$(task status:pending export | jq -r '.[].project' | sort | uniq)
    
    if [[ -z "$plans" ]]; then
        success "No active plans!"
        return
    fi
    
    while IFS= read -r plan; do
        [[ -z "$plan" ]] && continue
        local pending
        pending=$(task "project:$plan" status:pending 2>/dev/null | grep -c "^[0-9]" || echo "0")
        local active
        active=$(task "project:$plan" +ACTIVE 2>/dev/null | grep -c "^[0-9]" || echo "0")
        local blocked
        blocked=$(task "project:$plan" +BLOCKED 2>/dev/null | grep -c "^[0-9]" || echo "0")
        
        echo -e "${CYAN}● $plan${NC}"
        echo -e "  Pending: $pending | Active: $active | Blocked: $blocked"
        echo ""
    done <<< "$plans"
}

# Command: active - Show currently active tasks
cmd_active() {
    info "Currently active tasks:"
    echo ""
    task +ACTIVE 2>/dev/null || warning "No active tasks"
}

# Command: blocked - Show blocked tasks
cmd_blocked() {
    info "Blocked tasks:"
    echo ""
    task +BLOCKED 2>/dev/null || success "No blocked tasks"
}

# Command: overdue - Show overdue tasks
cmd_overdue() {
    info "Overdue tasks:"
    echo ""
    task due.before:today status:pending 2>/dev/null || success "No overdue tasks"
}

# Command: urgent - Make task urgent
cmd_urgent() {
    local task_id="$1"
    local urgency="${2:-15.0}"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    task "$task_id" modify "urgency:$urgency" priority:H
    success "Task $task_id marked as urgent (urgency: $urgency)"
}

# Command: block - Add dependency
cmd_block() {
    local task_id="$1"
    local depends_on="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$depends_on" ]] && error "Dependency task ID required"
    
    task "$task_id" modify "depends:$depends_on"
    success "Task $task_id now depends on task $depends_on"
}

# Command: unblock - Remove dependency
cmd_unblock() {
    local task_id="$1"
    local depends_on="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$depends_on" ]] && error "Dependency task ID required"
    
    # Get current dependencies
    local current_deps
    current_deps=$(task "$task_id" export | jq -r '.[0].depends // [] | join(",")')
    
    # Remove the specific dependency
    local new_deps
    new_deps=$(echo "$current_deps" | tr ',' '\n' | grep -v "^$depends_on$" | tr '\n' ',' | sed 's/,$//')
    
    if [[ -n "$new_deps" ]]; then
        task "$task_id" modify "depends:$new_deps"
    else
        task "$task_id" modify depends:
    fi
    
    success "Removed dependency on task $depends_on from task $task_id"
}

# Command: wait - Put task on hold
cmd_wait() {
    local task_id="$1"
    local date="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$date" ]] && error "Wait date required (e.g., friday, 2026-02-01)"
    
    task "$task_id" modify "wait:$date"
    success "Task $task_id waiting until $date"
}

# Main command dispatcher
main() {
    [[ $# -eq 0 ]] && { show_usage; exit 0; }
    
    local command="$1"
    shift
    
    case "$command" in
        plan)       cmd_plan "$@" ;;
        plans)      cmd_plans "$@" ;;
        next)       cmd_next "$@" ;;
        execute)    cmd_execute "$@" ;;
        done)       cmd_done "$@" ;;
        pause)      cmd_pause "$@" ;;
        note)       cmd_note "$@" ;;
        context)    cmd_context "$@" ;;
        status)     cmd_status "$@" ;;
        active)     cmd_active "$@" ;;
        blocked)    cmd_blocked "$@" ;;
        overdue)    cmd_overdue "$@" ;;
        urgent)     cmd_urgent "$@" ;;
        block)      cmd_block "$@" ;;
        unblock)    cmd_unblock "$@" ;;
        wait)       cmd_wait "$@" ;;
        help|-h|--help) show_usage ;;
        *)          error "Unknown command: $command (use '$SCRIPT_NAME help' for usage)" ;;
    esac
}

main "$@"
