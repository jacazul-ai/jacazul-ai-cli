#!/bin/bash
# Taskwarrior Flow - Imperative commands for task management
# Makes Taskwarrior easier to use for AI agents

set -e

SCRIPT_NAME="tw-flow"
VERSION="1.3.0"

# Detect JAKA_REAL_TASK if not provided (Dynamics)
if [ -z "$JAKA_REAL_TASK" ]; then
    JAKA_REAL_TASK=$(which -a task 2>/dev/null | grep -v "/scripts/task" | head -n 1)
    [ -z "$JAKA_REAL_TASK" ] && JAKA_REAL_TASK="/usr/bin/task"
    export JAKA_REAL_TASK
fi

# Set absolute paths for internal tools
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TASKP_BIN="$SCRIPT_DIR/taskp"
PONDER_BIN="$SCRIPT_DIR/ponder"

# Detect project and set TASKDATA if PROJECT_ID is available
detect_and_set_taskdata() {
    if [ -z "$TASKRC" ] && [ "$JAKA_MODE" = "UNHINGED" ]; then
        export TASKRC="$HOME/.candango/jaka_ai/.taskrc"
    fi

    if [ -z "$TASKDATA" ] && [ -n "$PROJECT_ID" ]; then
        if [ "$JAKA_MODE" = "UNHINGED" ]; then
            export TASKDATA="$HOME/.candango/jaka_ai/.task/$PROJECT_ID"
        else
            export TASKDATA="$HOME/.task/$PROJECT_ID"
        fi
    fi
    
    if [ -n "$TASKDATA" ]; then
        mkdir -p "$TASKDATA"
    fi
}

# Set TASKDATA before doing anything
detect_and_set_taskdata

# --- FOCUS SYSTEM HELPERS ---

get_focus_file() {
    echo "$TASKDATA/focus.json"
}

# Initialize or load the focus file
load_focus() {
    local file
    file=$(get_focus_file)
    if [ ! -f "$file" ]; then
        echo '{"focused_ini": null, "focused_task_uuid": null, "task_track": [], "inis_of_interest": []}' > "$file"
    fi
    cat "$file"
}

# Save focus state
save_focus() {
    local json="$1"
    local file
    file=$(get_focus_file)
    echo "$json" > "$file"
}

# Update a specific focus field
update_focus() {
    local key="$1"
    local value="$2"
    local json
    json=$(load_focus)
    
    if [[ "$value" == "null" ]]; then
        json=$(echo "$json" | jq ".$key = null")
    else
        json=$(echo "$json" | jq ".$key = \"$value\"")
    fi
    save_focus "$json"
}

# Push a task to the focus stack (as an object with ini)
push_task_focus() {
    local uuid="$1"
    local json
    json=$(load_focus)
    
    # Resolve the initiative for this task
    local ini
    ini=$("$TASKP_BIN" "$uuid" export | jq -r '.[0].project // ""')
    
    # Construct stack item
    local item
    item=$(jq -n --arg uuid "$uuid" --arg ini "$ini" '{uuid: $uuid, ini: $ini}')
    
    # Remove if already exists (bring to top) then push
    json=$(echo "$json" | jq ".task_track = ([$item] + (.task_track | map(select(.uuid != \"$uuid\"))))")
    json=$(echo "$json" | jq ".focused_task_uuid = \"$uuid\" | .focused_ini = \"$ini\"")
    save_focus "$json"
}

# Pop from the focus stack
pop_task_focus() {
    local json
    json=$(load_focus)
    
    local stack_size
    stack_size=$(echo "$json" | jq '.task_track | length')
    
    if [[ "$stack_size" -le 1 ]]; then
        json=$(echo "$json" | jq ".task_track = [] | .focused_task_uuid = null | .focused_ini = null")
    else
        json=$(echo "$json" | jq ".task_track = .task_track[1:]")
        local new_top_uuid new_top_ini
        new_top_uuid=$(echo "$json" | jq -r '.task_track[0].uuid')
        new_top_ini=$(echo "$json" | jq -r '.task_track[0].ini')
        json=$(echo "$json" | jq ".focused_task_uuid = \"$new_top_uuid\" | .focused_ini = \"$new_top_ini\"")
    fi
    save_focus "$json"
}

# Helper functions
error() {
    echo -e "ERROR: $1" >&2
    exit 1
}

success() {
    echo -e "‚úì $1"
}

info() {
    echo -e "‚Ñπ $1"
}

warning() {
    echo -e "‚ö† $1"
}

# Helper: Shorten UUID for display (8 chars)
short_id() {
    local id="$1"
    if [[ "$id" =~ ^[0-9a-fA-F-]{8,}$ ]]; then
        echo "${id:0:8}"
    else
        echo "$id"
    fi
}

# Helper: Resolve UUID (expand short UUID or validate full UUID)
resolve_uuid() {
    local input="$1"
    
    # If it's already a full UUID (36 chars with dashes), return it
    if [[ "$input" =~ ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$ ]]; then
        echo "$input"
        return 0
    fi
    
    # If it's a numeric ID, find the matching task UUID
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        local full_uuid
        full_uuid=$("$TASKP_BIN" export 2>/dev/null | jq -r ".[] | select(.id == $input) | .uuid" | head -1)
        if [[ -n "$full_uuid" ]] && [[ "$full_uuid" != "null" ]]; then
            echo "$full_uuid"
            return 0
        fi
    fi

    # If it's a short UUID (8 chars), find the matching task
    if [[ "$input" =~ ^[0-9a-fA-F]{8}$ ]]; then
        local full_uuid
        full_uuid=$("$TASKP_BIN" export 2>/dev/null | jq -r ".[] | select(.uuid | startswith(\"$input\")) | .uuid" | head -1)
        if [[ -n "$full_uuid" ]] && [[ "$full_uuid" != "null" ]]; then
            echo "$full_uuid"
            return 0
        fi
    fi
    
    # Otherwise, assume it's a valid identifier and return as-is
    echo "$input"
}



show_usage() {
    cat <<EOF
Taskwarrior Flow - Simplified task management commands

USAGE:
    $SCRIPT_NAME <command> [options]

COMMANDS:

  Initiatives:
    initiative|ini <initiative> <tasks...>    Create a new initiative with multiple tasks
                                       Tasks format: "mode|description|tag|due_offset"
                                       Modes: DESIGN, INVESTIGATE, GUIDE, EXECUTE, TEST, DEBUG, REVIEW, PR-REVIEW
    
  Execution:
    next [initiative]                Show next task(s) ready to work
    execute <id>                       Start working on a task
    done <id> [note]                   Complete a task with optional note
    outcome <id> <message>             Record final outcome before closing
    handoff <id> <message>             Start next task and add handoff note
    pause <id>                         Pause work on a task
    
  Context:
    note <id> <type> <message>         Add structured annotation
                                       Types: research, decision, blocked, lesson, ac, note, link
    context <id>                       Show full task context (annotations, deps, etc.)
    focus [ini|task|pop|clear]         Manage session focus (Anchor System)
    
  Viewing:
    initiatives|inis                              List all initiatives with pending tasks
    status [initiative]              Show initiative status overview
    active                             Show currently active tasks
    blocked                            Show blocked tasks
    overdue                            Show overdue tasks
    
  Modifications:
    urgent <id> [urgency]              Make task urgent (default: 15.0)
    block <id> <depends_on_id>         Add dependency to task
    unblock <id> <depends_on_id>       Remove dependency from task
    wait <id> <date>                   Put task on hold until date
    discard <id>                       Soft delete - move to trash and mark done
    tree [project]                     Show visual dependency tree
    discard <id>                       Soft delete - move to trash and mark done

EXAMPLES:

  # Create a 3-task initiative with modes
  $SCRIPT_NAME initiative login-feature \\
    "DESIGN|Design auth flow|research|today" \\
    "EXECUTE|Implement JWT|implementation|tomorrow" \\
    "TEST|Write tests|testing|2days"

  # See what's next
  $SCRIPT_NAME next login-feature

  # Start working
  $SCRIPT_NAME execute 42

  # Add research note
  $SCRIPT_NAME note 42 research "Found passport.js library"

  # Record outcome
  $SCRIPT_NAME outcome 42 "Implemented OAuth login flow"

  # Complete task
  $SCRIPT_NAME done 42

  # Handoff to next task
  $SCRIPT_NAME handoff 43 "Pick up implementation. See Task 42 for design docs."

  # Check status
  $SCRIPT_NAME status login-feature
  $SCRIPT_NAME done 42 "Completed design phase"

  # Check status
  $SCRIPT_NAME status login-feature

EOF
}

# Command: initiative - Create a new initiative with tasks
cmd_initiative() {
    local initiative="$1"
    shift
    
    [[ -z "$initiative" ]] && error "Initiative name required"
    [[ $# -eq 0 ]] && error "At least one task required"
    
    info "Creating initiative: $initiative"
    
    local urgency=9.0
    local task_ids=()
    local prev_id=""
    
    for task_spec in "$@"; do
        # Parse mode|description|tag|due_offset
        IFS='|' read -r mode description tag due_offset <<< "$task_spec"
        
        # If the first field isn't a known mode, assume the old format (description|tag|due)
        # or that mode was omitted.
        if [[ ! "$mode" =~ ^(DESIGN|PLAN|INVESTIGATE|GUIDE|EXECUTE|TEST|DEBUG|REVIEW|PR-REVIEW)$ ]]; then
            # Shift everything right
            due_offset=$tag
            tag=$description
            description=$mode
            mode=""
        fi

        [[ -z "$description" ]] && error "Task description cannot be empty"
        
        # Format description with mode
        local final_desc="$description"
        if [[ -n "$mode" ]]; then
            final_desc="[$mode] $description"
        fi

        # Set defaults
        tag=${tag:-implementation}
        due_offset=${due_offset:-today}
        
        # Build task command with priority based on position
        local priority="M"
        if (( $(echo "$urgency >= 9.0" | bc -l) )); then
            priority="H"
        elif (( $(echo "$urgency <= 3.0" | bc -l) )); then
            priority="L"
        fi
        
        # Build task command arguments
        local args=(add project:"$initiative" "$final_desc" due:"$due_offset" priority:"$priority" "+$tag")
        [[ -n "$prev_id" ]] && args+=(depends:"$prev_id")
        
        # Execute and capture ID
        local output
        output=$("$TASKP_BIN" "${args[@]}" 2>&1)
        local new_id
        new_id=$(echo "$output" | grep -oP 'Created task \K\d+' || echo "")
        
        if [[ -n "$new_id" ]]; then
            task_ids+=("$new_id")
            success "Created task $new_id: $final_desc [priority: $priority]"
            prev_id="$new_id"
        else
            echo "DEBUG: Command output: $output" >&2
            error "Failed to create task: $final_desc"
        fi
        
        # Decrease urgency for next task
        urgency=$(echo "$urgency - 2.0" | bc)
    done
    
    echo ""
    success "Initiative created with ${#task_ids[@]} tasks"
    info "Task IDs: ${task_ids[*]}"
    info "First task ready to work: ${task_ids[0]}"
}

# Command: next - Show next task(s) ready to work
cmd_next() {
    local filter="${1:-status:pending}"
    
    if [[ "project:$filter" != status:* ]] && [[ "project:$filter" != * ]]; then
        filter="$filter status:pending"
    fi
    
    info "Next tasks ready to work:"
    echo ""
    
    "$TASKP_BIN" "project:$filter" ready 2>/dev/null || warning "No tasks ready"
}

# Helper: Get inherited context from parent tasks (dependencies)
get_parent_context() {
    local task_id="$1"
    local json
    json=$("$TASKP_BIN" "$task_id" export 2>/dev/null | jq '.[0]')
    
    # UUIDs of dependencies
    local deps
    deps=$(echo "$json" | jq -r '.depends // [] | join(" ")')
    
    if [[ -n "$deps" ]]; then
        local found_context=false
        for dep_uuid in $deps; do
            local dep_json
            dep_json=$("$TASKP_BIN" "$dep_uuid" export 2>/dev/null | jq '.[0]')
            [[ -z "$dep_json" || "$dep_json" == "null" ]] && continue
            
            local dep_desc=$(echo "$dep_json" | jq -r '.description')
            local uuid=$(echo "$dep_json" | jq -r '.uuid')
            
            # Extract relevant annotations
            local annotations
            annotations=$(echo "$dep_json" | jq -r '.annotations // [] | .[] | select(.description | test("^(OUTCOME|DECISION|LESSON|HANDOFF):")) | .description')
            
            if [[ -n "$annotations" ]]; then
                if [[ "$found_context" == false ]]; then
                    echo -e "\n‚ïê‚ïê INHERITED CONTEXT ‚ïê‚ïê"
                    found_context=true
                fi
                echo -e "Task (${uuid:0:8}) [$dep_desc]:"
                echo "$annotations" | sed 's/^/  - /'
            fi
        done
        [[ "$found_context" == true ]] && echo ""
    fi
}

# Command: execute - Start working on a task
cmd_execute() {
    local input_id="$1"
    local task_id
    task_id=$(resolve_uuid "$input_id")
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Check if task is blocked
    local status
    status=$("$TASKP_BIN" "$task_id" export 2>/dev/null | jq -r '.[0].status // "notfound"')
    
    [[ "$status" == "notfound" ]] && error "Task $task_id not found"
    
    local tags
    tags=$("$TASKP_BIN" "$task_id" export 2>/dev/null | jq -r '.[0].tags // [] | join(" ")')
    
    if [[ "$tags" == *"BLOCKED"* ]]; then
        error "Task $task_id is BLOCKED by dependencies"
    fi
    
    # Show inherited context from dependencies
    get_parent_context "$task_id"

    "$TASKP_BIN" "$task_id" start
    success "Started working on task $(short_id "$task_id")"
    
    # Show task info
    echo ""
    "$TASKP_BIN" "$task_id"
}

# Validate that task has OUTCOME annotation
validate_outcome() {
    local task_id="$1"
    
    if "$TASKP_BIN" "$task_id" info 2>/dev/null | grep -qi "OUTCOME:"; then
        return 0
    else
        error "Task $task_id cannot be completed without an OUTCOME record.\n   Don't sweat it! Just record what you achieved first: tw-flow outcome $task_id \"your result\"\n   This keeps our project history solid and helps future agents (or you) stay in context."
    fi
}

# Command: done - Complete a task
cmd_done() {
    local task_id="$1"
    local note="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Validate outcome before completing
    validate_outcome "$task_id" || exit 1
    
    # Add completion note if provided
    if [[ -n "$note" ]]; then
        "$TASKP_BIN" "$task_id" annotate "DONE: $note"
    fi
    
    export TW_FLOW_INTERNAL=true
    "$TASKP_BIN" "$task_id" done
    success "Task $task_id completed!"
    # Check if any tasks were unblocked
    echo ""
    info "Checking for newly unblocked tasks..."
    local unblocked
    unblocked=$("$TASKP_BIN" status:pending ready 2>/dev/null | grep -c "^[0-9]" || echo "0")
    
    if [[ "$unblocked" -gt 0 ]]; then
        success "$unblocked task(s) now ready to work"
    "$TASKP_BIN" status:pending ready limit:3
    fi
}

# Command: pause - Pause work on a task
cmd_pause() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    "$TASKP_BIN" "$task_id" stop
    success "Paused task $(short_id "$task_id")"
}

# Command: outcome - Record final outcome
cmd_outcome() {
    local task_id="$1"
    shift
    local message="$*"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$message" ]] && error "Outcome message required"
    
    "$TASKP_BIN" "$task_id" annotate "OUTCOME: $message"
    success "Recorded outcome for task $(short_id "$task_id")"
}

# Command: handoff - Start next task and add handoff note
cmd_handoff() {
    local task_id="$1"
    shift
    local message="$*"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$message" ]] && error "Handoff message required"
    
    # Execute the next task
    cmd_execute "$task_id"
    
    # Add the handoff note
    "$TASKP_BIN" "$task_id" annotate "HANDOFF: $message"
    success "Handoff to task $task_id with note"
}

# Command: note - Add structured annotation
cmd_note() {
    local task_id="$1"
    local type="$2"
    shift 2
    local message="$*"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$type" ]] && error "Note type required (research, decision, blocked, lesson, ac, note, link)"
    [[ -z "$message" ]] && error "Note message required"
    
    # Convert type to uppercase prefix
    local prefix
    case "$type" in
        research|r)   prefix="RESEARCH" ;;
        decision|d)   prefix="DECISION" ;;
        blocked|b)    prefix="BLOCKED" ;;
        lesson|l)     prefix="LESSON" ;;
        ac|a)         prefix="AC" ;;
        note|n)       prefix="NOTE" ;;
        link)         prefix="LINK" ;;
        *)            error "Invalid note type: $type" ;;
    esac
    
    "$TASKP_BIN" "$task_id" annotate "$prefix: $message"
    success "Added $prefix note to task $task_id"
}

# Command: context - Show full task context
cmd_context() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Resolve UUID if short UUID provided
    task_id=$(resolve_uuid "$task_id")
 
    info "Full context for task $task_id:"
    echo ""
    "$TASKP_BIN" "$task_id" info
}

# Command: status - Show initiative status overview
cmd_status() {
    local filter="$1"
    local initiative_name
    
    # Load focus data
    local focus_json
    focus_json=$(load_focus)
   local focused_ini
    focused_ini=$(echo "$focus_json" | jq -r '.focused_ini // ""')
    local focused_task
    focused_task=$(echo "$focus_json" | jq -r '.focused_task_uuid // ""')

    if [[ -z "$filter" ]]; then
        if [[ -n "$focused_ini" ]]; then
            initiative_name="$focused_ini"
            filter="project:$initiative_name"
        else
            # Try to detect active initiative from current active task
            initiative_name=$("$TASKP_BIN" +ACTIVE export | jq -r '.[0].project // ""')
            if [[ -z "$initiative_name" ]]; then
                # Fallback to all pending tasks if no active task
                filter="status:pending"
                initiative_name="ALL ACTIVE"
            else
                filter="project:$initiative_name"
            fi
        fi
    else
        if [[ "$filter" =~ ^project: ]]; then
            initiative_name="${filter#project:}"
        elif [[ "$filter" == "status:pending" ]]; then
            initiative_name="ALL ACTIVE"
        else
            initiative_name="$filter"
            filter="project:$filter"
        fi
    fi
 
    # Custom initiative status overview
    local tasks_json
    tasks_json=$("$TASKP_BIN" "$filter" export)
    
    local tasks_list
    tasks_list=$(echo "$tasks_json" | jq -r '.[] | select(.status=="pending") | {uuid: .uuid, id: .id, active: (.start!=null), desc: .description} | @base64')
    
    local total_pending
    total_pending=$(echo "$tasks_json" | jq -r '[.[] | select(.status=="pending")] | length')
    
    local active_uuid
    active_uuid=$(echo "$tasks_json" | jq -r '.[] | select(.status=="pending" and .start!=null) | .uuid' | head -n1)
    
    local next_uuid
    next_uuid=$(echo "$tasks_json" | jq -r '.[] | select(.status=="pending" and .start==null) | .uuid' | head -n1)
    
    echo -e "‚ïê‚ïê Initiative: $initiative_name ‚ïê‚ïê"
    [[ -n "$focused_ini" ]] && [[ "$initiative_name" == "$focused_ini" ]] && echo -e "üìå ANCHORED SESSION"

    # Display recursive context if a task is focused
    if [[ -n "$focused_task" ]]; then
        echo -e "\nüéØ FOCUS CONTEXT [$(short_id "$focused_task")]:"
        get_parent_context "$focused_task" | sed 's/^/  /'
        "$TASKP_BIN" "$focused_task" export | jq -r '.[0].annotations // [] | .[] | "  - \(.description)"'
    fi

    if [[ "$total_pending" -gt 0 ]]; then
        echo -e "\nPENDING:"
        echo "$tasks_list" | while read -r task; do
            t=$(echo "$task" | base64 -d)
            uuid=$(echo "$t" | jq -r '.uuid')
            short_uuid=$(short_id "$uuid")
            desc=$(echo "$t" | jq -r '.desc')
            if [[ "$uuid" == "$active_uuid" ]]; then
                echo -e "- ‚úì [$short_uuid - ACTIVE] $desc"
            elif [[ "$uuid" == "$focused_task" ]]; then
                echo -e "- üéØ [$short_uuid - FOCUSED] $desc"
            else
                echo -e "- [$short_uuid] $desc"
            fi
        done
    else
        success "No pending tasks found for this filter."
    fi

    # Display completed tasks if any
    local completed_list
    completed_list=$(echo "$tasks_json" | jq -r '.[] | select(.status=="completed") | "‚úì [\(.uuid | .[0:8])] \(.description)"' || echo "")
    if [[ -n "$completed_list" ]]; then
        echo -e "\nCOMPLETED:"
        echo "$completed_list" | sed 's/^/  /'
    fi
    
    echo -e "\nTotal: $total_pending tasks. Active: $(short_id "$active_uuid"). Next: $(short_id "$next_uuid").\n"
    
    # Count tasks by status using the JSON we already have
    local pending active blocked completed
    pending=$(echo "$tasks_json" | jq -r '[.[] | select(.status=="pending")] | length')
    active=$(echo "$tasks_json" | jq -r '[.[] | select(.status=="pending" and .start!=null)] | length')
    blocked=$(echo "$tasks_json" | jq -r '[.[] | select(.status=="pending" and .tags!=null and (.tags | contains(["BLOCKED"])))] | length')
    completed=$(echo "$tasks_json" | jq -r '[.[] | select(.status=="completed")] | length')
    
    echo -e "Completed: $completed"
    echo -e "Active: $active"
    echo -e "Blocked: $blocked"
    echo -e "Pending: $((pending - active))"
    echo ""
}

# Command: initiatives - List all initiatives with pending tasks
cmd_initiatives() {
    info "Initiatives with pending tasks:"
    echo ""
    
    local initiatives_json
    initiatives_json=$("$TASKP_BIN" status:pending export)
    
    local initiative_names
    initiative_names=$(echo "$initiatives_json" | jq -r '.[].project' | sort | uniq | grep -v "^$" || echo "")
    
    if [[ -z "$initiative_names" ]]; then
        success "No active initiatives!"
        return
    fi
    
    while IFS= read -r initiative; do
        [[ -z "$initiative" ]] && continue
        
        local pending active blocked
        pending=$(echo "$initiatives_json" | jq -r "[.[] | select(.project==\"$initiative\")] | length")
        active=$(echo "$initiatives_json" | jq -r "[.[] | select(.project==\"$initiative\" and .start!=null)] | length")
        blocked=$(echo "$initiatives_json" | jq -r "[.[] | select(.project==\"$initiative\" and .tags!=null and (.tags | contains([\"BLOCKED\"])))] | length")
        
        echo -e "‚óè $initiative"
        echo -e "  Pending: $((pending - active)) | Active: $active | Blocked: $blocked"
        echo ""
    done <<< "$initiative_names"
}

# Command: active - Show currently active tasks
cmd_active() {
    info "Currently active tasks:"
    echo ""
    "$TASKP_BIN" +ACTIVE 2>/dev/null || warning "No active tasks"
}

# Command: blocked - Show blocked tasks
cmd_blocked() {
    info "Blocked tasks:"
    echo ""
    "$TASKP_BIN" +BLOCKED 2>/dev/null || success "No blocked tasks"
}

# Command: overdue - Show overdue tasks
cmd_overdue() {
    info "Overdue tasks:"
    echo ""
    "$TASKP_BIN" due.before:today status:pending 2>/dev/null || success "No overdue tasks"
}

# Command: urgent - Make task urgent
cmd_urgent() {
    local task_id="$1"
    local urgency="${2:-15.0}"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    "$TASKP_BIN" "$task_id" modify "urgency:$urgency" priority:H
    success "Task $task_id marked as urgent (urgency: $urgency)"
}

# Command: block - Add dependency
cmd_block() {
    local task_id="$1"
    local depends_on="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$depends_on" ]] && error "Dependency task ID required"
    
    "$TASKP_BIN" "$task_id" modify "depends:$depends_on"
    success "Task $task_id now depends on task $depends_on"
}

# Command: unblock - Remove dependency
cmd_unblock() {
    local task_id="$1"
    local depends_on="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$depends_on" ]] && error "Dependency task ID required"
    
    # Get current dependencies
    local current_deps
    current_deps=$("$TASKP_BIN" "$task_id" export | jq -r '.[0].depends // [] | join(",")')
    
    # Remove the specific dependency
    local new_deps
    new_deps=$(echo "$current_deps" | tr ',' '\n' | grep -v "^$depends_on$" | tr '\n' ',' | sed 's/,$//')
    
    if [[ -n "$new_deps" ]]; then
    "$TASKP_BIN" "$task_id" modify "depends:$new_deps"
    else
    "$TASKP_BIN" "$task_id" modify depends:
    fi
    
    success "Removed dependency on task $depends_on from task $task_id"
}

# Command: wait - Put task on hold
cmd_wait() {
    local task_id="$1"
    local date="$2"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    [[ -z "$date" ]] && error "Wait date required (e.g., friday, 2026-02-01)"
    
    "$TASKP_BIN" "$task_id" modify "wait:$date"
    success "Task $task_id waiting until $date"
}

# Soft delete - move task to trash
cmd_discard() {
    local task_id="$1"
    
    [[ -z "$task_id" ]] && error "Task ID required"
    
    # Get current project to preserve context in trash
    local current_project
    current_project=$("$TASKP_BIN" "$task_id" export 2>/dev/null | jq -r '.[0].project // "unscoped"')
    
    # Move to _archive project (soft delete)
    local archive_project="${current_project%:_archive}:_archive"
    
    export TW_FLOW_INTERNAL=true
    "$TASKP_BIN" "$task_id" modify project:"$archive_project" +DISCARDED
    "$TASKP_BIN" "$task_id" annotate "OUTCOME: Task discarded and moved to archive."
    "$TASKP_BIN" "$task_id" done
    
        success "Task $(short_id "$task_id") moved to archive and marked done."
    }
    
# Command: focus - Manage session focus (Anchor System)
cmd_focus() {
    local sub="$1"
    [[ -n "$sub" ]] && shift
    
    case "$sub" in
        ini)
            local name="$1"
            [[ -z "$name" ]] && {
                # If no name provided, try to detect from active task
                name=$("$TASKP_BIN" +ACTIVE export | jq -r '.[0].project // ""')
                [[ -z "$name" ]] && error "No active task found to anchor initiative. Please specify name."
            }
            
            # Anchor to initiative but PRESERVE the task stack
            update_focus "focused_ini" "$name"
            
            # Automatically anchor to the 'next' task in this initiative and push to heap
            local next_uuid
            next_uuid=$("$TASKP_BIN" "project:$name" status:pending limit:1 export | jq -r '.[0].uuid // ""')
            if [[ -n "$next_uuid" ]] && [[ "$next_uuid" != "null" ]]; then
                push_task_focus "$next_uuid"
                success "Focused initiative anchored to: $name (Task pushed to heap: $(short_id "$next_uuid"))"
            else
                success "Focused initiative anchored to: $name (No pending tasks found)"
            fi
            ;;
        interest)
            local action="$1"
            local name="$2"
            local json
            json=$(load_focus)
            
            case "$action" in
                add)
                    [[ -z "$name" ]] && error "Initiative name required"
                    json=$(echo "$json" | jq ".inis_of_interest = (.inis_of_interest + [\"$name\"] | unique)")
                    save_focus "$json"
                    success "Added '$name' to interests."
                    ;;
                remove)
                    [[ -z "$name" ]] && error "Initiative name required"
                    json=$(echo "$json" | jq ".inis_of_interest = (.inis_of_interest | map(select(. != \"$name\")))")
                    save_focus "$json"
                    success "Removed '$name' from interests."
                    ;;
                list)
                    echo -e "‚ïê‚ïê Initiatives of Interest ‚ïê‚ïê"
                    echo "$json" | jq -r '.inis_of_interest[]' || echo "(empty)"
                    ;;
                *)
                    error "Usage: focus interest [add|remove|list] <name>"
                    ;;
            esac
            ;;
        task)
            local input_id="$1"
            [[ -z "$input_id" ]] && error "Task ID required"
            local uuid
            uuid=$(resolve_uuid "$input_id")
            push_task_focus "$uuid"
            success "Focused task anchored to: $(short_id "$uuid") (pushed to stack)"
            ;;
        pop)
            pop_task_focus
            local top
            top=$(load_focus | jq -r '.focused_task_uuid // "none"')
            success "Popped task focus. Current top: $top"
            ;;
        clear)
            save_focus '{"focused_ini": null, "focused_task_uuid": null, "task_track": [], "inis_of_interest": []}'
            success "Focus and task track cleared."
            ;;
        *)
            # Show current focus
            local json
            json=$(load_focus)
            echo -e "‚ïê‚ïê Current Session Focus ‚ïê‚ïê"
            echo "$json" | jq .
            ;;
    esac
}
    
    cmd_tree() {
    
    local filter="${1:-status:pending}"
    if [[ "project:$filter" != status:* ]] && [[ "project:$filter" != * ]]; then
        filter="project:$filter"
    fi

    local project_name
    project_name=$(echo "project:$filter" | sed 's/^//')
    echo -e "‚ïê‚ïê Initiative: $project_name ‚ïê‚ïê"

    # Helper for recursive tree rendering
    render_tree_node() {
        local uuid="$1"
        local indent="$2"
        local is_last="$3"

        local json
        json=$("$TASKP_BIN" "$uuid" export 2>/dev/null | jq '.[0]')
        [[ -z "$json" || "$json" == "null" ]] && return

        local desc=$(echo "$json" | jq -r '.description')
        local status=$(echo "$json" | jq -r '.status')
        local start=$(echo "$json" | jq -r '.start // ""')

        local icon="‚óã"
        [[ "$status" == "completed" ]] && icon="‚úì"
        [[ -n "$start" ]] && icon="‚ö°"
        
        # Check if blocked
        local is_ready
        is_ready=$("$TASKP_BIN" "$uuid" +READY export 2>/dev/null | jq -r '.[0].id // ""')
        if [[ "$status" == "pending" && -z "$is_ready" ]]; then
            icon="üîí"
        fi

        local marker="‚îú‚îÄ‚îÄ"
        [[ "$is_last" == "true" ]] && marker="‚îî‚îÄ‚îÄ"
        [[ -z "$indent" ]] && marker=""

        printf "%b%b %b (%s) | %s\n" "$indent" "$marker" "$icon" "${uuid:0:8}" "$desc"

        # Find children (tasks that depend on this one)
        local children
        children=$("$TASKP_BIN" "depends.contains:$uuid" status:pending export 2>/dev/null | jq -r '.[] | select(.project | test("_archive$|_trash$") | not) | .uuid' || echo "")
        
        local child_indent="$indent    "
        [[ "$marker" == "‚îú‚îÄ‚îÄ" ]] && child_indent="$indent‚îÇ   "
        [[ -z "$indent" ]] && child_indent=""

        local count
        count=$(echo "$children" | grep -c . || echo 0)
        local i=1
        while read -r child_uuid; do
            [[ -z "$child_uuid" ]] && continue
            local last_child="false"
            [[ "$i" -eq "$count" ]] && last_child="true"
            render_tree_node "$child_uuid" "$child_indent" "$last_child"
            i=$((i+1))
        done <<< "$children"
    }

    # Find root nodes (tasks in project with no dependencies or whose dependencies are outside this project/completed)
    local root_uuids
    root_uuids=$("$TASKP_BIN" "project:$filter" export 2>/dev/null | jq -r '.[] | select(.project | test("_archive$|_trash$") | not) | select(.depends == null or (.depends | length == 0)) | .uuid')

    if [[ -z "$root_uuids" ]]; then
        # If no strict roots, just show all tasks in project as a list for now
    "$TASKP_BIN" "project:$filter" export 2>/dev/null | jq -r '.[] | select(.project | test("_archive$|_trash$") | not) | .uuid' | while read -r uuid; do
             [[ -n "$uuid" ]] && render_tree_node "$uuid" "" "false"
        done
    else
        while read -r uuid; do
            [[ -n "$uuid" ]] && render_tree_node "$uuid" "" "false"
        done <<< "$root_uuids"
    fi
}

# Main command dispatcher
main() {
    [[ $# -eq 0 ]] && { show_usage; exit 0; }
    
    local command="$1"
    shift
    
    case "$command" in
        initiative|ini)       cmd_initiative "$@" ;;
        initiatives|inis)      cmd_initiatives "$@" ;;
        next)       cmd_next "$@" ;;
        execute)    cmd_execute "$@" ;;
        done)       cmd_done "$@" ;;
        outcome)    cmd_outcome "$@" ;;
        handoff)    cmd_handoff "$@" ;;
        pause)      cmd_pause "$@" ;;
        note)       cmd_note "$@" ;;
        context)    cmd_context "$@" ;;
        status)     cmd_status "$@" ;;
        active)     cmd_active "$@" ;;
        blocked)    cmd_blocked "$@" ;;
        overdue)    cmd_overdue "$@" ;;
        urgent)     cmd_urgent "$@" ;;
        block)      cmd_block "$@" ;;
        unblock)    cmd_unblock "$@" ;;
        wait)       cmd_wait "$@" ;;
        discard)    cmd_discard "$@" ;;
        tree)       cmd_tree "$@" ;;
        focus)      cmd_focus "$@" ;;
        help|-h|--help) show_usage ;;
        *)          error "Unknown command: $command (use '$SCRIPT_NAME help' for usage)" ;;
    esac
}

main "$@"
